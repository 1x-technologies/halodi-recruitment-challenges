# Embedded Development

This challenge evaluates your coding skills and basic embedded engineering knowledge.

## Challenge

Included with this case study you will find a simple C++ project that simulates a very simple motor driver.
The motor driver communicates over a synchronous protocol (SPI) with the master.
The synchronous protocol is simulated through `motordriver.h`.

- The main goal of this case study is to evaluate your programming skills
- The case study is to be completed in C++, using Object Oriented Design
- Program to the C++11 standard or higher (make sure to update the `CMakeLists.txt` to the standard of your choosing)
- Feel free to look up as much as you want, but do implement the answers in your own coding style. Do not plagiarize, and provide citations if warranted
- We are looking for good programming practises demonstrating clean, re-usable, extendable, and maintainable code
- Feel free to make assumptions and document them if information is missing in the case
- Add documentation where necessary
  - Document public API functions. Use good class, function, and variable names
- Develop against a local git repository, and commit at least after every question
- If using test driven development, show that using commits
- Send the whole repository (including the .git directory) when finished as a zip archive
  - Remove the files generated by CMakeList and/or your compiler

Included with the project is [a simplified datasheet](motor-driver-datasheet.pdf) for the motor driver.
Make sure to follow that.
The example code is not finished and does not include all limitations described in the datasheet.

### Task 1: Interfacing with the (emulated) motor driver using a Finite State Machine

Implement a finite state machine on the master side to interface with the motor driver.
The goal is for the state machine to match the state of the motor driver, and to transition the motor driver to the next state based on the transition conditions.

- Use object oriented design methodology for the state machine code.
- You should not have to change the motor driver emulation code to implement the state machine.
- All communication between the motor driver and master goes through the `transfer()` function.
  - This simulates a SPI like communication between the master and motor driver.
- Implement the following transitions

| State  | Next state | Transition condition                                                                                     | On entry                    | Action                            | On Exit        |
| ------ | ---------- | -------------------------------------------------------------------------------------------------------- | --------------------------- | --------------------------------- | -------------- |
| BOOT   | PREOP      | Automatic on the motor driver. Read the status register to determine when to switch the master to PREOP. |                             |                                   |                |
| PREOP  | SAFEOP     | Immediate                                                                                                |                             |                                   |                |
| SAFEOP | OP         | Fault register on motor driver not set                                                                   | Write zero to encoder value | Read encoder; Clear fault flag    |                |
| OP     | SAFEOP     | Fault register on motor driver set                                                                       | Enable output               | Read encoder; Write motor command | Disable output |

### Task 2: Extend the motor driver emulation code to test the finite state machine

In this task you will extend the included minimalistic `motordriver.cpp` to test the master code.

On the motor driver, make sure to include at least the following functionality:

- Check if the checksum is calculated correctly
- Add delay till boot switches to preop
- Check if a state change is valid

**Note:** When the motor driver receives an invalid command, it should set the fault register.

On the master side, implement automated test cases to test the correctness of the state machine youâ€™ve implemented. Make sure to test for correct and incorrect transitions.

**Tip:** An invalid command send from the master could be determined by reading the fault register.

Clearly report to the user if a test case fails.

Make sure that if the reviewer runs an incorrect implementation of the state machine, the test case will fail.
